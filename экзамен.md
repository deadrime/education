### 1. Сравнение двух видов программной кросплатформенности
    
+ На уровне исходного кода кроссплатформенность означает, что для разных платформ исходный код будет одинаков, и программист не задумывается над особенностями ОС или железа. Например, мы знаем, что в разных ОС и для разных процессоров длина целочисленного типа в байтах может быть разной если мы пишем на Си - этот код не кроссплатформенный (макросы не учитываем). Если мы пишем на С# то для всех платформ мы получаем корректный байткод из одного и того же исходника.
+ На уровне исполняемых модулей кроссплатформенность допускает применение одних и тех же модулей не зависимо от целевой платформы. В самой библиотеке может быть реализован разный код под разные платформы, и конкретная реализация выбирается в реалтайме в зависимости от внешних условий. Например, модуль sys в питоне предоставляет одинаковый API для всех поддерживаемых платформ, хотя для разных ОС в итоге юзаются совершенно разные варианты.

### 2. Общая классификация ОС

**Классификацию операционных систем можно осуществлять несколькими способами.**

По способу организации вычислений:

+ системы пакетной обработки (batch processing operating systems) – целью является выполнение максимального количества вычислительных задач за единицу времени; при этом из нескольких задач формируется пакет, который обрабатывается системой;
+ системы разделения времени (time-sharing operating systems) – целью является возможность одновременного использования одного компьютера несколькими пользователями; реализуется посредством поочередного предоставления каждому + +  + пользователю интервала процессорного времени;
+ системы реального времени (real-time operating systems) – целью является выполнение каждой задачи за строго определённый для данной задачи интервал времени.

По типу ядра:

+ системы с монолитным ядром (monolithic operating systems);
+ системы с микроядром (microkernel operating systems);
+ системы с гибридным ядром (hybrid operating systems).

По количеству одновременно решаемых задач:

+ однозадачные (single-tasking operating systems);
+ многозадачные (multitasking operating systems).

По количеству одновременно работающих пользователей:

+ однопользовательские (single-user operating systems);
+ многопользовательские (multi-user operating systems).

По количеству поддерживаемых процессоров:

+ однопроцессорные (uniprocessor operating systems);
+ многопроцессорные (multiprocessor operating systems).

По поддержке сети:

+ локальные (local operating systems) – автономные системы, не предназначенные для работы в компьютерной сети;
+ сетевые (network operating systems) – системы, имеющие компоненты, позволяющие работать с компьютерными сетями.

По роли в сетевом взаимодействии:

+ серверные (server operating systems) – операционные системы, предоставляющие доступ к ресурсам сети и управляющие сетевой инфраструктурой;
+ клиентские (client operating systems) – операционные системы, которые могут получать доступ к ресурсам сети.

По типу лицензии:

+ открытые (open-source operating systems) – операционные системы с открытым исходным кодом, доступным для изучения и изменения;
+ проприетарные (proprietary operating systems) – операционные системы, которые имеют конкретного правообладателя; обычно поставляются с закрытым исходным кодом.

**ОС UNIX имеет следующие основные характеристики:**

+ переносимость;
+ многозадачность;
+ поддержка одновременной работы многих пользователей;
+ поддержка асинхронных процессов;
+ иерархическая файловая система;
+ поддержка независимых от устройств операций ввода-вывода (через специальные файлы устройств);
+ стандартный интерфейс для программ (программные каналы, IPC) и пользователей (командный интерпретатор, не входящий в ядро ОС);
+ встроенные средства учета использования системы.
###3. Аппаратная кроссплатформенность
+ 1)Использование виртуальной машины,например java. - Для компиляции используется виртальная машина,которая выполняет байт-код, созданный компилятором. Суть в том, что компилируется не машинный код, разный для разных архитектур, а байт-код, который выполняет виртуальная машина.
Минус - производительность. Интерпретируемые языки работают медленнее, чем компилируемые.

+ 2)Использование различных кросплатформенных фреймворков. Например QT - для разработки ПО на С++. Ну или PyQt - на питоне. Эти фреймворки позволяют создавать приложение для разных ОС, но требуют перекомпиляции под разные архитектуры.

### 4. Основные типы файлов в UNIX.

![](http://younglinux.info/sites/default/files/images/filestype.preview.png)

Атрибуты:
+ A (no Access time) - у файла не обновляектся время последнего доступа
+ а (append only) - файл открыт для записи
+ d (no dump) - игнорировать при создании резервной копии программой dump
+ i (ummutable) - запрет на изменение.
+ s (secure deletion) - полное удаление файла (место на диске, где он находился, после заполняется нулями)
+ u (undeletable) - после удаления файла, его содержимое сохраняется, т.е. есть возможнось восстановить такой файл в будущем.
+ S (synchronous updates) - прямая запись на диск, без кэширования (обновления в файла происходит на диске синхронно с приложением, изменяющим данный файл)

### 5. Способы перенаправления стандартных потоков ввода-вывода

Каждая запущенная из командного интерпретатора программа получает три открытых потока ввода/вывода:

- стандартный ввод (sldin)
- стандартный вывод( sldout)
- стандартный вывод ошибок (stderr)

Дескриптор(идентификатор):

- Стандартный поток ввода - 0
- Стандартный поток вывода - 1
- Стандартный поток ошибок - 2

Перенаправление:

- '>' - перенаправление стандартного потока вывода
- '>>' - перенаправление стандартного потока вывода в режиме до записи
- '<' - перенаправление стандартного потока ввода
- '<<' - получение данные из стандартного потока ввода до тех пор, пока не встретится разделитель

Оболочка Bash позволяет перенаправить стандартные потоки, для чего используются следующие операторы:
- r < — оператор перенаправления стандартного потока ввода;
- r > или 1> — операторы перенаправления стандартного потока вывода;
- r 2> — оператор перенаправления стандартного потока вывода ошибок.


### 6.Особенности асинхронного запуска приложений с помощью служб cron и screen.
Screen позволяет управлять несколькими сессиями из одной консоли или окна терминала. Утилита незаменима, когда к одному сеансу надо подключиться из двух мест одновременно или взаимодействовать с несколькими сессиями.

screen работает на сервере, инициатором запроса будет объект screen и запрос уже не оборвётся не при каких проблемах клиента. При обрыве связи процессы не останавливаются, а продолжают работать, и к ним можно вернуться в любой момент.

Например при потере связи по ssh, можно вернуться в свою сессию, а выполняемые в момент разрыва операции не прервутся.

cron – программа-демон, предназначенная для выполнения заданий в определенное время, или через определенные промежутки времени.

Вы можете автоматически выполнять некоторые свои программы через определенные интервалы времени. Напимер каждые 30 минут или каждый день. Это бывает очень полезно для проведения обслуживания вашего сайта.

### 7.Различия при работе с файловыми системами в Unix и Windows.

+ Windows - FAT32, NTFS. , Unix - ext2,ext3,ext4.

+ Windws - множество корневых каталогов(деревьев), Unix - одно каталог, одно дерево, внутри которого уже лежат различные разделы, можно монтировать диски куда угодно.
![](http://www.softrew.ru/uploads/posts/2012-10/1349110893_linux-file-system.jpg)

+ Windows - нечувствителен к регистру(abs.txt и Abs.txt могут лежать в одной директории), Unix - наоборот

+ Слеши в разные стороны (/ - unix , \ - windows)

+ Unix позволяет работать с открытыми файлами

+ Linux не имеет реестра. Приложения на машинах с Linux хранят свои настройки в специальной программе с правами выше юзера. 

### 8.Использование оператолров if и for в bash.
Общий синтаксис оператора if:
```
if список1 then
список2
[elif список3 then
список4]
[else 
список5]
fi
```

Пример:

```
if [ $count -eq 42 ]
then
  echo "42 является корректным значением."
elif [ $count -gt 42 ]
then
  echo "Слишком много."
else
  echo "Не достаточно."
fi

```

-gt : больше
-rq :равно

Когда if и then располагаются в одной строке, то конструкции if и then должны завершаться точкой с запятой. 

Арифметические операции можно выполнять как в c++, но внутри двойных скобок.


Цикл for - 
```
for i in 1 2 4
do
   echo $i
done
```

### 9. Различные способы запуска приложений из командной строки.

+ Просто написать имя приложения или языка пограммирования, например firefox, наутилус или python

+ Чтобы запустить скрипт:
    1)Указать язык, на котором он напиан, пробел, имя файла
    2)./имя_скрипта, в самом скрипте желательно указать интерпретатор языка(строку ассоциации)  #!/usr/bin/python. к примеру или #!/bin/sh
    
### 10. Работа с переменными окружения. Системные и пользовательские переменные, постоянные и временные значения переменных окружения.

Какие бывают:

+ Пользовательские -определяются для конкретного пользователя, хранятся в файлах конфигурации в директории пользователя.
+ Системные -доступны для всей системы, всех пользователей, загружаются при старте системы из системных файлов конфигурации.

Добавление:

var=значение
export var=значение

Список всех - env

Удаление:
env -i [var=значение]
unset имя_переменной

Это изменит переменные в рамках сессии, на системном уровне нужно добавлять это в /etc/environment
 
Для конкретного пользователя - в /.bash_profile

Используется для изменения PATH, чтобы работала, например, JAVA


### 11. Безопасная работа с текстом при разработке кроссплатформенных приложений.



### 12.Основные утилиты Unix для работы с файловой системой

+ pwd   - получить имя текущей директории
+ cd    - изменить текущую директорию
+ ls    - распечатать информацию о файлах или директориях
+ cat   - слить или вывести файлы-аргументы на стандартный вывод
+ cp    - копировать файлы
+ mv    - переместить (переименовать) файлы
+ ln    - создать ссылку на файл
+ rm    - удалить файлы
+ rmdir - удалить директорию
+ mkdir - создать директорию

### 13.Способы хранения и передачи данных о времени и дате.

+ date - текущее время
+ date - в UTС

### 14.Базовые структуры данных с последовательным и произвольным доступом. Сравнение эффективности выполнения различных операций с ними.

Структуры данных, в которых возможен непосредственный доступ к произвольным их элементам, называют структурами данных с прямым, или с произвольным доступом.

В других структурах данных непосредственный доступ возможен лишь к одному или нескольким элементам, для доступа к остальным элементам надо выполнить дополнительные действия. Такие структуры данных называются структурами последовательного доступа.

![](https://upload.wikimedia.org/wikipedia/commons/5/54/Произвольный_случайный_доступ-ru.svg)

Если я правильно понял - вопрос про работу со списками(последовательный доступ) и массивами(произвольный)

Если так, то плюсы списка -  легко вставлять, удалять элементы, сортировать.

Вставка элемента в спиок выполняется быстрее, для массива нужно выполнять сдвиг, для списка - просто изменить указатели.

Сортировка списка не требует работы с самими данными, только с указателями. 

Минусы - требуется больше памяти на указатели, можно получить доступ только с следующему и предыдущему элемент. Чтобы получить доступ к последнему элементу, нужно пройти по всему списку или же хранить указатель на конец отдельно.

### 15.Работа с аргументами командной строки в сценариях bash.

Чтобы передать аргументы из командной строки в скрипт , указывается имя скрипты и аргументы через пробел. Чтобы программа могла считать эти аргументы используются переменные с номерами:

$1 — первый параметр, $2 — второй параметр и т. д. Также существуют две вспомогательные переменные: $# содержит количество переданных аргументов; $@ содержит все аргументы, переданные скрипту, разделенные пробелами.

```
# Цикл выдаст все переданные аргументы
for n in $@
do
  echo "$n"
done
```

Диалог с пользователем можно организовать при помощи case или if, учитывая введенные им аргументы.

### 16. На python - аргументы содержатся в sys.argv

Чтобы получить все параметры - можно использовать цикл

```Python
for param in sys.argv:
    print (param)
```

Или же напрямую - 
```
sys.argv[1] //Доступ к первому аргументы
```
Если используется именнованный параметр, например SomeName-n:

```
param_name = sys.argv[1]
param_value = sys.argv[1]
```
И работать уже с ними.

Есть так же удабная библиотека argparse


Простейший принцип работы с argparse следующий:

+ Создаем экземпляр класса ArgumentParser.
+ Добавляем в него информацию об ожидаемых параметрах с помощью метода add_argument (по одному вызову на каждый параметр). 
+ Разбираем командную строку помощью метода parse_args, передавая ему полученные параметры командной строки (кроме нулевого элемента списка sys.argv).
+ Начинаем использовать полученные параметры.

