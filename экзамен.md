### 1. Сравнение двух видов программной кросплатформенности
    
+ На уровне исходного кода кроссплатформенность означает, что для разных платформ исходный код будет одинаков, и программист не задумывается над особенностями ОС или железа. Например, мы знаем, что в разных ОС и для разных процессоров длина целочисленного типа в байтах может быть разной если мы пишем на Си - этот код не кроссплатформенный (макросы не учитываем). Если мы пишем на С# то для всех платформ мы получаем корректный байткод из одного и того же исходника.
+ На уровне исполняемых модулей кроссплатформенность допускает применение одних и тех же модулей не зависимо от целевой платформы. В самой библиотеке может быть реализован разный код под разные платформы, и конкретная реализация выбирается в реалтайме в зависимости от внешних условий. Например, модуль sys в питоне предоставляет одинаковый API для всех поддерживаемых платформ, хотя для разных ОС в итоге юзаются совершенно разные варианты.

### 2. Общая классификация ОС

**Классификацию операционных систем можно осуществлять несколькими способами.**

По способу организации вычислений:

+ системы пакетной обработки (batch processing operating systems) – целью является выполнение максимального количества вычислительных задач за единицу времени; при этом из нескольких задач формируется пакет, который обрабатывается системой;
+ системы разделения времени (time-sharing operating systems) – целью является возможность одновременного использования одного компьютера несколькими пользователями; реализуется посредством поочередного предоставления каждому + +  + пользователю интервала процессорного времени;
+ системы реального времени (real-time operating systems) – целью является выполнение каждой задачи за строго определённый для данной задачи интервал времени.

По типу ядра:

+ системы с монолитным ядром (monolithic operating systems);
+ системы с микроядром (microkernel operating systems);
+ системы с гибридным ядром (hybrid operating systems).

По количеству одновременно решаемых задач:

+ однозадачные (single-tasking operating systems);
+ многозадачные (multitasking operating systems).

По количеству одновременно работающих пользователей:

+ однопользовательские (single-user operating systems);
+ многопользовательские (multi-user operating systems).

По количеству поддерживаемых процессоров:

+ однопроцессорные (uniprocessor operating systems);
+ многопроцессорные (multiprocessor operating systems).

По поддержке сети:

+ локальные (local operating systems) – автономные системы, не предназначенные для работы в компьютерной сети;
+ сетевые (network operating systems) – системы, имеющие компоненты, позволяющие работать с компьютерными сетями.

По роли в сетевом взаимодействии:

+ серверные (server operating systems) – операционные системы, предоставляющие доступ к ресурсам сети и управляющие сетевой инфраструктурой;
+ клиентские (client operating systems) – операционные системы, которые могут получать доступ к ресурсам сети.

По типу лицензии:

+ открытые (open-source operating systems) – операционные системы с открытым исходным кодом, доступным для изучения и изменения;
+ проприетарные (proprietary operating systems) – операционные системы, которые имеют конкретного правообладателя; обычно поставляются с закрытым исходным кодом.

**ОС UNIX имеет следующие основные характеристики:**

+ переносимость;
+ многозадачность;
+ поддержка одновременной работы многих пользователей;
+ поддержка асинхронных процессов;
+ иерархическая файловая система;
+ поддержка независимых от устройств операций ввода-вывода (через специальные файлы устройств);
+ стандартный интерфейс для программ (программные каналы, IPC) и пользователей (командный интерпретатор, не входящий в ядро ОС);
+ встроенные средства учета использования системы.
###3. Аппаратная кроссплатформенность
+ 1)Использование виртуальной машины,например java. - Для компиляции используется виртальная машина,которая выполняет байт-код, созданный компилятором. Суть в том, что компилируется не машинный код, разный для разных архитектур, а байт-код, который выполняет виртуальная машина.
Минус - производительность. Интерпретируемые языки работают медленнее, чем компилируемые.

+ 2)Использование различных кросплатформенных фреймворков. Например QT - для разработки ПО на С++. Ну или PyQt - на питоне. Эти фреймворки позволяют создавать приложение для разных ОС, но требуют перекомпиляции под разные архитектуры.

### 4. Основные типы файлов в UNIX.

![](http://younglinux.info/sites/default/files/images/filestype.preview.png)

Атрибуты:
+ A (no Access time) - у файла не обновляектся время последнего доступа
+ а (append only) - файл открыт для записи
+ d (no dump) - игнорировать при создании резервной копии программой dump
+ i (ummutable) - запрет на изменение.
+ s (secure deletion) - полное удаление файла (место на диске, где он находился, после заполняется нулями)
+ u (undeletable) - после удаления файла, его содержимое сохраняется, т.е. есть возможнось восстановить такой файл в будущем.
+ S (synchronous updates) - прямая запись на диск, без кэширования (обновления в файла происходит на диске синхронно с приложением, изменяющим данный файл)

### 5. Способы перенаправления стандартных потоков ввода-вывода

Каждая запущенная из командного интерпретатора программа получает три открытых потока ввода/вывода:

- стандартный ввод (sldin)
- стандартный вывод( sldout)
- стандартный вывод ошибок (stderr)

Дескриптор(идентификатор):

- Стандартный поток ввода - 0
- Стандартный поток вывода - 1
- Стандартный поток ошибок - 2

Перенаправление:

- '>' - перенаправление стандартного потока вывода
- '>>' - перенаправление стандартного потока вывода в режиме до записи
- '<' - перенаправление стандартного потока ввода
- '<<' - получение данные из стандартного потока ввода до тех пор, пока не встретится разделитель

Оболочка Bash позволяет перенаправить стандартные потоки, для чего используются следующие операторы:
- r < — оператор перенаправления стандартного потока ввода;
- r > или 1> — операторы перенаправления стандартного потока вывода;
- r 2> — оператор перенаправления стандартного потока вывода ошибок.


### 6.Особенности асинхронного запуска приложений с помощью служб cron и screen.
Screen позволяет управлять несколькими сессиями из одной консоли или окна терминала. Утилита незаменима, когда к одному сеансу надо подключиться из двух мест одновременно или взаимодействовать с несколькими сессиями.

screen работает на сервере, инициатором запроса будет объект screen и запрос уже не оборвётся не при каких проблемах клиента. При обрыве связи процессы не останавливаются, а продолжают работать, и к ним можно вернуться в любой момент.

Например при потере связи по ssh, можно вернуться в свою сессию, а выполняемые в момент разрыва операции не прервутся.

cron – программа-демон, предназначенная для выполнения заданий в определенное время, или через определенные промежутки времени.

Вы можете автоматически выполнять некоторые свои программы через определенные интервалы времени. Напимер каждые 30 минут или каждый день. Это бывает очень полезно для проведения обслуживания вашего сайта.

### 7.Различия при работе с файловыми системами в Unix и Windows.

+ Windows - FAT32, NTFS. , Unix - ext2,ext3,ext4.

+ Windws - множество корневых каталогов(деревьев), Unix - одно каталог, одно дерево, внутри которого уже лежат различные разделы, можно монтировать диски куда угодно.
![](http://www.softrew.ru/uploads/posts/2012-10/1349110893_linux-file-system.jpg)

+ Windows - нечувствителен к регистру(abs.txt и Abs.txt могут лежать в одной директории), Unix - наоборот

+ Слеши в разные стороны (/ - unix , \ - windows)

+ Unix позволяет работать с открытыми файлами

+ Linux не имеет реестра. Приложения на машинах с Linux хранят свои настройки в специальной программе с правами выше юзера. 

### 8.Использование операторов if и for в bash.

Общий синтаксис оператора if:
```
if список1 then
список2
[elif список3 then
список4]
[else 
список5]
fi
```

Пример:

```
if [ $count -eq 42 ]
then
  echo "42 является корректным значением."
elif [ $count -gt 42 ]
then
  echo "Слишком много."
else
  echo "Не достаточно."
fi

```

-gt : больше
-rq :равно

Когда if и then располагаются в одной строке, то конструкции if и then должны завершаться точкой с запятой. 

Арифметические операции можно выполнять как в c++, но внутри двойных скобок.


Цикл for - 
```
for i in 1 2 4
do
   echo $i
done
```

### 9. Различные способы запуска приложений из командной строки.

+ Просто написать имя приложения или языка пограммирования, например firefox, nautilus или python

+ Чтобы запустить скрипт:
    1)Указать язык, на котором он напиcан, пробел, имя файла
    2)./имя_скрипта, в самом скрипте желательно указать интерпретатор языка(строку ассоциации)  #!/usr/bin/python. к примеру или #!/bin/sh
    
### 10. Работа с переменными окружения. Системные и пользовательские переменные, постоянные и временные значения переменных окружения.

Какие бывают:

+ Пользовательские -определяются для конкретного пользователя, хранятся в файлах конфигурации в директории пользователя.
+ Системные -доступны для всей системы, всех пользователей, загружаются при старте системы из системных файлов конфигурации.

Добавление:

var=значение
export var=значение

Список всех - env

Удаление:
env -i [var=значение]
unset имя_переменной

Это изменит переменные в рамках сессии, на системном уровне нужно добавлять это в /etc/environment
 
Для конкретного пользователя - в /.bash_profile

Используется для изменения PATH, чтобы работала, например, JAVA


### 11. Безопасная работа с текстом при разработке кроссплатформенных приложений.



### 12.Основные утилиты Unix для работы с файловой системой

+ pwd   - получить имя текущей директории
+ cd    - изменить текущую директорию
+ ls    - распечатать информацию о файлах или директориях
+ cat   - слить или вывести файлы-аргументы на стандартный вывод
+ cp    - копировать файлы
+ mv    - переместить (переименовать) файлы
+ ln    - создать ссылку на файл
+ rm    - удалить файлы
+ rmdir - удалить директорию
+ mkdir - создать директорию

### 13.Способы хранения и передачи данных о времени и дате.

+ date - текущее время
+ date - в UTС

### 14.Базовые структуры данных с последовательным и произвольным доступом. Сравнение эффективности выполнения различных операций с ними.

Структуры данных, в которых возможен непосредственный доступ к произвольным их элементам, называют структурами данных с прямым, или с произвольным доступом.

В других структурах данных непосредственный доступ возможен лишь к одному или нескольким элементам, для доступа к остальным элементам надо выполнить дополнительные действия. Такие структуры данных называются структурами последовательного доступа.

![](https://upload.wikimedia.org/wikipedia/commons/5/54/Произвольный_случайный_доступ-ru.svg)

Если я правильно понял - вопрос про работу со списками(последовательный доступ) и массивами(произвольный)

Если так, то плюсы списка -  легко вставлять, удалять элементы, сортировать.

Вставка элемента в спиок выполняется быстрее, для массива нужно выполнять сдвиг, для списка - просто изменить указатели.

Сортировка списка не требует работы с самими данными, только с указателями. 

Минусы - требуется больше памяти на указатели, можно получить доступ только с следующему и предыдущему элемент. Чтобы получить доступ к последнему элементу, нужно пройти по всему списку или же хранить указатель на конец отдельно.

В python есть следующие структуры данных - 

+ Списки - однородные данные

list = [1,2,3,4]

+ Кортежи - различные типы данных

c = [1,'2',True]

Могут быть вложенные кортежи - 
с = [1,'2',[1,True,False]]

+ Cловари - имеют ключ и значение по ключу.
dict = {}
dict[key]=value - добавить в словарь
dict[key] - значение по ключу


|         | Образуется по индексу | Замена содержимого | Добавление несуществующих элементов | Синтаксис |
|:-------:|:---------------------:|:------------------:|:-----------------------------------:|:---------:|
|  Список |           +           |          +         |                  -                  |     []    |
| Словарь |           +           |          +         |                  +                  |     {}    |
|  Кортеж |           +           |          -         |                  -                  | () или [] |

### 15.Работа с аргументами командной строки в сценариях bash.

Чтобы передать аргументы из командной строки в скрипт , указывается имя скрипты и аргументы через пробел. Чтобы программа могла считать эти аргументы используются переменные с номерами:

$1 — первый параметр, $2 — второй параметр и т. д. Также существуют две вспомогательные переменные: $# содержит количество переданных аргументов; $@ содержит все аргументы, переданные скрипту, разделенные пробелами.

```
# Цикл выдаст все переданные аргументы
for n in $@
do
  echo "$n"
done
```

Диалог с пользователем можно организовать при помощи case или if, учитывая введенные им аргументы.

### 16. Работа с аргументами командной строки в программах на python.
В python - аргументы содержатся в sys.argv

Чтобы получить все параметры - можно использовать цикл

```Python
for param in sys.argv:
    print (param)
```

Или же напрямую - 
```
sys.argv[1] //Доступ к первому аргументы
```
Если используется именнованный параметр, например SomeName-n:

```
param_name = sys.argv[1]
param_value = sys.argv[1]
```
И работать уже с ними.

Есть так же удабная библиотека argparse

Простейший принцип работы с argparse следующий:

+ Создаем экземпляр класса ArgumentParser.
+ Добавляем в него информацию об ожидаемых параметрах с помощью метода add_argument (по одному вызову на каждый параметр). 
+ Разбираем командную строку помощью метода parse_args, передавая ему полученные параметры командной строки (кроме нулевого элемента списка sys.argv).
+ Начинаем использовать полученные параметры.

### 17.Лямбда-выражения на примерах сортировки сложных структур данных (python).

Иногда нужно передать функцию в качестве аргумента или сделать короткую, но сложную операцию несколько раз. Можно определить функцию обычным способом, а можно использовать лямбда-функцию — маленькую функцию, возвращающую результат одного выражения. Следующие два определения полностью идентичны:

def add(a,b): return a+b

add2 = lambda a,b: a+b

Преимущество лямбда-функции в том, что она является выражением и может быть использована внутри другого выражения.

Допустим у нас есть такая структура(кортеж) - Имя, Фамилия, Возраст, Рост

Имя и строка будут строками, возраст - целое, рост - с плавающей запятой

Теперь, например, у нас есть список этих структур

a = [['Вася','Пупкин',13,160],['Иван','Иванов',16,130],['Мария','Иванова',11,150]]

Если попробовать отсортировать это (a.sort()), то сортировка произведется по первому столбцу и в алфавитном порядке. (Имена в алфавитном порядке в на)

При сортировке сложных структур можно использовать key, чтобы изменить принцип сортировки. В key передается некая функция, которая определяет сортировку. Эта функция вернет значение, по которому и будет выполнена сортировка.

Например нам нужно вернуть из vasya = ['Вася','Пупкин',13,160] фамилию, тогда vasya[1] - это ключ (по второму столбцу).

Для этого можно использовать лямбда функцию - 

a.sort(key=lambda i: i[n])

Это на вход этой функции подавется кортеж, а она возвращает из него n-й элемент.


Например 
```
a = [['Вася','Пупкин',13,160],['Иван','Иванов',16,130],['Мария','Иванова',11,150]]

a.sort(key=lambda i: i[0]) - по имени
a.sort(key=lambda i: i[1]) - по фамилии
a.sort(key=lambda i: i[2]) - по возрасту
a.sort(key=lambda i: i[3]) - по росту

```

### 18. Основы ООП в python

Напомню - 

+ **Полиморфизм**: в разных объектах одна и та же операция может выполнять различные функции. Слово «полиморфизм» имеет греческую природу и означает «имеющий многие формы». Простым примером полиморфизма может служить функция count(), выполняющая одинаковое действие для различных типов обьектов: 'abc'.count('a') и [1, 2, 'a'].count('a'). Оператор плюс полиморфичен при сложении чисел и при сложении строк.

+ **Инкапсуляция**: можно скрыть ненужные внутренние подробности работы объекта от окружающего мира. Это второй основной принцип абстракции. Он основан на использовании атрибутов внутри класса. Атрибуты могут иметь различные состояния в промежутках между вызовами методов класса, вследствие чего сам объект данного класса также получает различные состояния — state.

+ **Наследование**: можно создавать специализированные классы на основе базовых. Это позволяет нам избегать написания повторного кода.


+ Создание класса - 
```
class имя_класса:
    некий_параметр1=
    некий_параметр2=
    
    def __init__(self,параметр1,параметр2):  # Конструктор класса
        ...
    def некая_функция1(self):  # Метод без параметров
        ....
    def некая_функция2(self,параметр1):  # Метод с параметром
        ...L
    def __del__(self):  # Деструктор класса
        ...
```
self указатель на текущий объект класса, нужен для обращения к атрибутам класса. 
В конструкторе можно не только инициализировать переменные но и создавать их.

+ Наследование
```Python
class класс_наследник(базовый_класс):
    ...
```

### 19. Итераторы и итерируемые объекты (python).

Итераторы — это специальные объекты, представляющие последовательный доступ к данным из контейнера. 

например у нас есть список list=[1,2,3,4,5] и мы хотим пройтись по нему (проитерировать его), можно использовать 

for iter in list:
    print iter

Можно итерировать списки, кортежи, словари

Можно создать итератор - 

```
a = [1,2,3,4,5,6,7,8]

iterator = iter(a);
print iterator.next() #1
print iterator.next() #2
```

.next() - перейти к следующему элементу

Генераторы это итерируемые объекты, которые не хранятся в памяти.


### 20. Awk
. Awk создан для обработки текста и создания отчетов, но у него много хорошо проработанных функций, дающих возможность серьезного программирования.

Логичесике :

+ || или
+ && и

Сравнения :

+ '=='
+ '!='
+ '<'
+ '>'
+ '<='
+ '>='

Кроме того, awk предоставляет операторы "~" и "!~", которые означают "совпадает" и "не совпадает". При их использовании переменная помещается слева от оператора, а регулярное выражение — справа от него.

awk '{print}' some_file- вывести весь текст

awk '/po/ {print}' some_file - строки, где встречается ро

работа с полями в файле - $1, $2 и т.д

awk {print $2}'  some_file - вывести вторую колонку(вторые поля строк) в файле

{a=$3 $4} - сложение строк
{a=$3+$4} - сложение значений

Можно создать ассоциативный массив

{sum[$1] +=$2;}

Есть условия
{
    if ($1 =="some") {
        print "ogo!"
    }
    else {
        print "aga!"
    }
    else if ($1=="tipidor")
        print "tipidor"
}

Блоки BEGIN и END  - аwk выполняется для каждой строчки, но можно например инициализировать что-то до того, как он начет обрабатывать текст, для этого нежен BEGIN

END указывает, что все строки обработаны, после него обычно подводятся итоги.
