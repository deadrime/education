#Оглавление
[1.Сравнение двух видов программной кросплатформенности](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#1-Сравнение-двух-видов-программной-кросплатформенности)
[2. Общая-классификация-ОС](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#2-Общая-классификация-ОС)
[4. Основные типы файлов в unix](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#4-Основные-типы-файлов-в-unix)
[5. Способы перенаправления стандартных потоков ввода-вывода](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#5-Способы-перенаправления-стандартных-потоков-ввода-вывода)
[6.Особенности асинхронного запуска приложений с помощью служб cron и screen.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#6Особенности-асинхронного-запуска-приложений-с-помощью-служб-cron-и-screen)
[8.Использование операторов if и for в bash.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#8Использование-операторов-if-и-for-в-bash)
[9. Различные способы запуска приложений из командной строки.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#9-Различные-способы-запуска-приложений-из-командной-строки)
[10. Работа с переменными окружения. Системные и пользовательские переменные, постоянные и временные значения переменных окружения.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#10-Работа-с-переменными-окружения-Системные-и-пользовательские-переменные-постоянные-и-временные-значения-переменных-окружения)
[11. Безопасная работа с текстом при разработке кроссплатформенных приложений.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#11-Безопасная-работа-с-текстом-при-разработке-кроссплатформенных-приложений)
[12.Основные утилиты Unix для работы с файловой системой](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#12Основные-утилиты-unix-для-работы-с-файловой-системой)
[13.Способы хранения и передачи данных о времени и дате.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#13Способы-хранения-и-передачи-данных-о-времени-и-дате)
[14.Базовые структуры данных с последовательным и произвольным доступом. Сравнение эффективности выполнения различных операций с ними.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#14Базовые-структуры-данных-с-последовательным-и-произвольным-доступом-Сравнение-эффективности-выполнения-различных-операций-с-ними)
[15.Работа с аргументами командной строки в сценариях bash.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#15Работа-с-аргументами-командной-строки-в-сценариях-bash)
[16. Работа с аргументами командной строки в программах на python.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#16-Работа-с-аргументами-командной-строки-в-программах-на-python)
[17.Лямбда-выражения на примерах сортировки сложных структур данных (python).]https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#17Лямбда-выражения-на-примерах-сортировки-сложных-структур-данных-python)
[18. Основы ООП в python](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#18-Основы-ООП-в-python)
[19. Итераторы и итерируемые объекты (python).](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#19-Итераторы-и-итерируемые-объекты-python)
[20. Awk](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#20-awk)
[21.Использование шаблонов имен файлов в оболочке bash.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#21Использование-шаблонов-имен-файлов-в-оболочке-bash)
[22. Простейшие регулярные выражения в командах grep и sed.](https://github.com/deadrime/education/blob/master/%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD.md#22-Простейшие-регулярные-выражения--в-командах-grep-и-sed)


### 1. Сравнение двух видов программной кросплатформенности
    
+ На уровне исходного кода кроссплатформенность означает, что для разных платформ исходный код будет одинаков, и программист не задумывается над особенностями ОС или железа. Например, мы знаем, что в разных ОС и для разных процессоров длина целочисленного типа в байтах может быть разной если мы пишем на Си - этот код не кроссплатформенный (макросы не учитываем). Если мы пишем на С# то для всех платформ мы получаем корректный байткод из одного и того же исходника.
+ На уровне исполняемых модулей кроссплатформенность допускает применение одних и тех же модулей не зависимо от целевой платформы. В самой библиотеке может быть реализован разный код под разные платформы, и конкретная реализация выбирается в реалтайме в зависимости от внешних условий. Например, модуль sys в питоне предоставляет одинаковый API для всех поддерживаемых платформ, хотя для разных ОС в итоге юзаются совершенно разные варианты.

### 2. Общая классификация ОС

**Классификацию операционных систем можно осуществлять несколькими способами.**

По способу организации вычислений:

+ системы пакетной обработки (batch processing operating systems) – целью является выполнение максимального количества вычислительных задач за единицу времени; при этом из нескольких задач формируется пакет, который обрабатывается системой;
+ системы разделения времени (time-sharing operating systems) – целью является возможность одновременного использования одного компьютера несколькими пользователями; реализуется посредством поочередного предоставления каждому + +  + пользователю интервала процессорного времени;
+ системы реального времени (real-time operating systems) – целью является выполнение каждой задачи за строго определённый для данной задачи интервал времени.

По типу ядра:

+ системы с монолитным ядром (monolithic operating systems);
+ системы с микроядром (microkernel operating systems);
+ системы с гибридным ядром (hybrid operating systems).

По количеству одновременно решаемых задач:

+ однозадачные (single-tasking operating systems);
+ многозадачные (multitasking operating systems).

По количеству одновременно работающих пользователей:

+ однопользовательские (single-user operating systems);
+ многопользовательские (multi-user operating systems).

По количеству поддерживаемых процессоров:

+ однопроцессорные (uniprocessor operating systems);
+ многопроцессорные (multiprocessor operating systems).

По поддержке сети:

+ локальные (local operating systems) – автономные системы, не предназначенные для работы в компьютерной сети;
+ сетевые (network operating systems) – системы, имеющие компоненты, позволяющие работать с компьютерными сетями.

По роли в сетевом взаимодействии:

+ серверные (server operating systems) – операционные системы, предоставляющие доступ к ресурсам сети и управляющие сетевой инфраструктурой;
+ клиентские (client operating systems) – операционные системы, которые могут получать доступ к ресурсам сети.

По типу лицензии:

+ открытые (open-source operating systems) – операционные системы с открытым исходным кодом, доступным для изучения и изменения;
+ проприетарные (proprietary operating systems) – операционные системы, которые имеют конкретного правообладателя; обычно поставляются с закрытым исходным кодом.

**ОС UNIX имеет следующие основные характеристики:**

+ переносимость;
+ многозадачность;
+ поддержка одновременной работы многих пользователей;
+ поддержка асинхронных процессов;
+ иерархическая файловая система;
+ поддержка независимых от устройств операций ввода-вывода (через специальные файлы устройств);
+ стандартный интерфейс для программ (программные каналы, IPC) и пользователей (командный интерпретатор, не входящий в ядро ОС);
+ встроенные средства учета использования системы.
###3. Аппаратная кроссплатформенность
+ 1)Использование виртуальной машины,например java. - Для компиляции используется виртальная машина,которая выполняет байт-код, созданный компилятором. Суть в том, что компилируется не машинный код, разный для разных архитектур, а байт-код, который выполняет виртуальная машина.
Минус - производительность. Интерпретируемые языки работают медленнее, чем компилируемые.

+ 2)Использование различных кросплатформенных фреймворков. Например QT - для разработки ПО на С++. Ну или PyQt - на питоне. Эти фреймворки позволяют создавать приложение для разных ОС, но требуют перекомпиляции под разные архитектуры.

### 4. Основные типы файлов в UNIX.

![](http://younglinux.info/sites/default/files/images/filestype.preview.png)

Атрибуты:
+ A (no Access time) - у файла не обновляектся время последнего доступа
+ а (append only) - файл открыт для записи
+ d (no dump) - игнорировать при создании резервной копии программой dump
+ i (ummutable) - запрет на изменение.
+ s (secure deletion) - полное удаление файла (место на диске, где он находился, после заполняется нулями)
+ u (undeletable) - после удаления файла, его содержимое сохраняется, т.е. есть возможнось восстановить такой файл в будущем.
+ S (synchronous updates) - прямая запись на диск, без кэширования (обновления в файла происходит на диске синхронно с приложением, изменяющим данный файл)

### 5. Способы перенаправления стандартных потоков ввода-вывода

Каждая запущенная из командного интерпретатора программа получает три открытых потока ввода/вывода:

- стандартный ввод (sldin)
- стандартный вывод( sldout)
- стандартный вывод ошибок (stderr)

Дескриптор(идентификатор):

- Стандартный поток ввода - 0
- Стандартный поток вывода - 1
- Стандартный поток ошибок - 2

Перенаправление:

- '>' - перенаправление стандартного потока вывода
- '>>' - перенаправление стандартного потока вывода в режиме до записи
- '<' - перенаправление стандартного потока ввода
- '<<' - получение данные из стандартного потока ввода до тех пор, пока не встретится разделитель

Оболочка Bash позволяет перенаправить стандартные потоки, для чего используются следующие операторы:
- r < — оператор перенаправления стандартного потока ввода;
- r > или 1> — операторы перенаправления стандартного потока вывода;
- r 2> — оператор перенаправления стандартного потока вывода ошибок.


### 6.Особенности асинхронного запуска приложений с помощью служб cron и screen.
Screen позволяет управлять несколькими сессиями из одной консоли или окна терминала. Утилита незаменима, когда к одному сеансу надо подключиться из двух мест одновременно или взаимодействовать с несколькими сессиями.

screen работает на сервере, инициатором запроса будет объект screen и запрос уже не оборвётся не при каких проблемах клиента. При обрыве связи процессы не останавливаются, а продолжают работать, и к ним можно вернуться в любой момент.

Например при потере связи по ssh, можно вернуться в свою сессию, а выполняемые в момент разрыва операции не прервутся.

cron – программа-демон, предназначенная для выполнения заданий в определенное время, или через определенные промежутки времени.

Вы можете автоматически выполнять некоторые свои программы через определенные интервалы времени. Напимер каждые 30 минут или каждый день. Это бывает очень полезно для проведения обслуживания вашего сайта.

### 7.Различия при работе с файловыми системами в Unix и Windows.

+ Windows - FAT32, NTFS. , Unix - ext2,ext3,ext4.

+ Windws - множество корневых каталогов(деревьев), Unix - одно каталог, одно дерево, внутри которого уже лежат различные разделы, можно монтировать диски куда угодно.
![](http://www.softrew.ru/uploads/posts/2012-10/1349110893_linux-file-system.jpg)

+ Windows - нечувствителен к регистру(abs.txt и Abs.txt могут лежать в одной директории), Unix - наоборот

+ Слеши в разные стороны (/ - unix , \ - windows)

+ Unix позволяет работать с открытыми файлами

+ Linux не имеет реестра. Приложения на машинах с Linux хранят свои настройки в специальной программе с правами выше юзера. 

### 8.Использование операторов if и for в bash.

Общий синтаксис оператора if:
```
if список1 then
список2
[elif список3 then
список4]
[else 
список5]
fi
```

Пример:

```
if [ $count -eq 42 ]
then
  echo "42 является корректным значением."
elif [ $count -gt 42 ]
then
  echo "Слишком много."
else
  echo "Не достаточно."
fi

```

-gt : больше
-rq :равно

Когда if и then располагаются в одной строке, то конструкции if и then должны завершаться точкой с запятой. 

Арифметические операции можно выполнять как в c++, но внутри двойных скобок.


Цикл for - 
```
for i in 1 2 4
do
   echo $i
done
```

### 9. Различные способы запуска приложений из командной строки.

+ Просто написать имя приложения или языка пограммирования, например firefox, nautilus или python

+ Чтобы запустить скрипт:
    1)Указать язык, на котором он напиcан, пробел, имя файла
    2)./имя_скрипта, в самом скрипте желательно указать интерпретатор языка(строку ассоциации)  #!/usr/bin/python. к примеру или #!/bin/sh
    
### 10. Работа с переменными окружения. Системные и пользовательские переменные, постоянные и временные значения переменных окружения.

Какие бывают:

+ Пользовательские -определяются для конкретного пользователя, хранятся в файлах конфигурации в директории пользователя.
+ Системные -доступны для всей системы, всех пользователей, загружаются при старте системы из системных файлов конфигурации.

Добавление:

var=значение
export var=значение

Список всех - env

Удаление:
env -i [var=значение]
unset имя_переменной

Это изменит переменные в рамках сессии, на системном уровне нужно добавлять это в /etc/environment
 
Для конкретного пользователя - в /.bash_profile

Используется для изменения PATH, чтобы работала, например, JAVA


### 11. Безопасная работа с текстом при разработке кроссплатформенных приложений.



### 12.Основные утилиты Unix для работы с файловой системой

+ pwd   - получить имя текущей директории
+ cd    - изменить текущую директорию
+ ls    - распечатать информацию о файлах или директориях
+ cat   - слить или вывести файлы-аргументы на стандартный вывод
+ cp    - копировать файлы
+ mv    - переместить (переименовать) файлы
+ ln    - создать ссылку на файл
+ rm    - удалить файлы
+ rmdir - удалить директорию
+ mkdir - создать директорию

### 13.Способы хранения и передачи данных о времени и дате.

+ date - текущее время
+ date - в UTС

### 14.Базовые структуры данных с последовательным и произвольным доступом. Сравнение эффективности выполнения различных операций с ними.

Структуры данных, в которых возможен непосредственный доступ к произвольным их элементам, называют структурами данных с прямым, или с произвольным доступом.

В других структурах данных непосредственный доступ возможен лишь к одному или нескольким элементам, для доступа к остальным элементам надо выполнить дополнительные действия. Такие структуры данных называются структурами последовательного доступа.

![](https://upload.wikimedia.org/wikipedia/commons/5/54/Произвольный_случайный_доступ-ru.svg)

Если я правильно понял - вопрос про работу со списками(последовательный доступ) и массивами(произвольный)

Если так, то плюсы списка -  легко вставлять, удалять элементы, сортировать.

Вставка элемента в спиок выполняется быстрее, для массива нужно выполнять сдвиг, для списка - просто изменить указатели.

Сортировка списка не требует работы с самими данными, только с указателями. 

Минусы - требуется больше памяти на указатели, можно получить доступ только с следующему и предыдущему элемент. Чтобы получить доступ к последнему элементу, нужно пройти по всему списку или же хранить указатель на конец отдельно.

В python есть следующие структуры данных - 

+ Списки - однородные данные

list = [1,2,3,4]

+ Кортежи - различные типы данных

c = [1,'2',True]

Могут быть вложенные кортежи - 
с = [1,'2',[1,True,False]]

+ Cловари - имеют ключ и значение по ключу.
dict = {}
dict[key]=value - добавить в словарь
dict[key] - значение по ключу


|         | Образуется по индексу | Замена содержимого | Добавление несуществующих элементов | Синтаксис |
|:-------:|:---------------------:|:------------------:|:-----------------------------------:|:---------:|
|  Список |           +           |          +         |                  -                  |     []    |
| Словарь |           +           |          +         |                  +                  |     {}    |
|  Кортеж |           +           |          -         |                  -                  | () или [] |

### 15.Работа с аргументами командной строки в сценариях bash.

Чтобы передать аргументы из командной строки в скрипт , указывается имя скрипты и аргументы через пробел. Чтобы программа могла считать эти аргументы используются переменные с номерами:

$1 — первый параметр, $2 — второй параметр и т. д. Также существуют две вспомогательные переменные: $# содержит количество переданных аргументов; $@ содержит все аргументы, переданные скрипту, разделенные пробелами.

```
# Цикл выдаст все переданные аргументы
for n in $@
do
  echo "$n"
done
```

Диалог с пользователем можно организовать при помощи case или if, учитывая введенные им аргументы.

### 16. Работа с аргументами командной строки в программах на python.
В python - аргументы содержатся в sys.argv

Чтобы получить все параметры - можно использовать цикл

```Python
for param in sys.argv:
    print (param)
```

Или же напрямую - 
```
sys.argv[1] //Доступ к первому аргументы
```
Если используется именнованный параметр, например SomeName-n:

```
param_name = sys.argv[1]
param_value = sys.argv[1]
```
И работать уже с ними.

Есть так же удабная библиотека argparse

Простейший принцип работы с argparse следующий:

+ Создаем экземпляр класса ArgumentParser.
+ Добавляем в него информацию об ожидаемых параметрах с помощью метода add_argument (по одному вызову на каждый параметр). 
+ Разбираем командную строку помощью метода parse_args, передавая ему полученные параметры командной строки (кроме нулевого элемента списка sys.argv).
+ Начинаем использовать полученные параметры.

### 17.Лямбда-выражения на примерах сортировки сложных структур данных (python).

Иногда нужно передать функцию в качестве аргумента или сделать короткую, но сложную операцию несколько раз. Можно определить функцию обычным способом, а можно использовать лямбда-функцию — маленькую функцию, возвращающую результат одного выражения. Следующие два определения полностью идентичны:

def add(a,b): return a+b

add2 = lambda a,b: a+b

Преимущество лямбда-функции в том, что она является выражением и может быть использована внутри другого выражения.

Допустим у нас есть такая структура(кортеж) - Имя, Фамилия, Возраст, Рост

Имя и строка будут строками, возраст - целое, рост - с плавающей запятой

Теперь, например, у нас есть список этих структур

a = [['Вася','Пупкин',13,160],['Иван','Иванов',16,130],['Мария','Иванова',11,150]]

Если попробовать отсортировать это (a.sort()), то сортировка произведется по первому столбцу и в алфавитном порядке. (Имена в алфавитном порядке в на)

При сортировке сложных структур можно использовать key, чтобы изменить принцип сортировки. В key передается некая функция, которая определяет сортировку. Эта функция вернет значение, по которому и будет выполнена сортировка.

Например нам нужно вернуть из vasya = ['Вася','Пупкин',13,160] фамилию, тогда vasya[1] - это ключ (по второму столбцу).

Для этого можно использовать лямбда функцию - 

a.sort(key=lambda i: i[n])

Это на вход этой функции подавется кортеж, а она возвращает из него n-й элемент.


Например 
```
a = [['Вася','Пупкин',13,160],['Иван','Иванов',16,130],['Мария','Иванова',11,150]]

a.sort(key=lambda i: i[0]) - по имени
a.sort(key=lambda i: i[1]) - по фамилии
a.sort(key=lambda i: i[2]) - по возрасту
a.sort(key=lambda i: i[3]) - по росту

```

### 18. Основы ООП в python

Напомню - 

+ **Полиморфизм**: в разных объектах одна и та же операция может выполнять различные функции. Слово «полиморфизм» имеет греческую природу и означает «имеющий многие формы». Простым примером полиморфизма может служить функция count(), выполняющая одинаковое действие для различных типов обьектов: 'abc'.count('a') и [1, 2, 'a'].count('a'). Оператор плюс полиморфичен при сложении чисел и при сложении строк.

+ **Инкапсуляция**: можно скрыть ненужные внутренние подробности работы объекта от окружающего мира. Это второй основной принцип абстракции. Он основан на использовании атрибутов внутри класса. Атрибуты могут иметь различные состояния в промежутках между вызовами методов класса, вследствие чего сам объект данного класса также получает различные состояния — state.

+ **Наследование**: можно создавать специализированные классы на основе базовых. Это позволяет нам избегать написания повторного кода.


+ Создание класса - 
```
class имя_класса:
    некий_параметр1=
    некий_параметр2=
    
    def __init__(self,параметр1,параметр2):  # Конструктор класса
        ...
    def некая_функция1(self):  # Метод без параметров
        ....
    def некая_функция2(self,параметр1):  # Метод с параметром
        ...L
    def __del__(self):  # Деструктор класса
        ...
```
self указатель на текущий объект класса, нужен для обращения к атрибутам класса. 
В конструкторе можно не только инициализировать переменные но и создавать их.

+ Наследование
```Python
class класс_наследник(базовый_класс):
    ...
```

### 19. Итераторы и итерируемые объекты (python).

Итераторы — это специальные объекты, представляющие последовательный доступ к данным из контейнера. 

например у нас есть список list=[1,2,3,4,5] и мы хотим пройтись по нему (проитерировать его), можно использовать 

for iter in list:
    print iter

Можно итерировать списки, кортежи, словари

Можно создать итератор - 

```
a = [1,2,3,4,5,6,7,8]

iterator = iter(a);
print iterator.next() #1
print iterator.next() #2
```

.next() - перейти к следующему элементу

Генераторы это итерируемые объекты, которые не хранятся в памяти.


### 20. Awk
. Awk создан для обработки текста и создания отчетов, но у него много хорошо проработанных функций, дающих возможность серьезного программирования.

Логичесике :

+ || или
+ && и

Сравнения :

+ '=='
+ '!='
+ '<'
+ '>'
+ '<='
+ '>='

Кроме того, awk предоставляет операторы "~" и "!~", которые означают "совпадает" и "не совпадает". При их использовании переменная помещается слева от оператора, а регулярное выражение — справа от него.

awk '{print}' some_file- вывести весь текст

awk '/po/ {print}' some_file - строки, где встречается ро

Если перед шаблоном поставить «!», он превратится в шаблон игнорирования строк. Пример: /^[0-9]/

работа с полями в файле - $1, $2 и т.д

awk {print $2}'  some_file - вывести вторую колонку(вторые поля строк) в файле

{a=$3 $4} - сложение строк
{a=$3+$4} - сложение значений

Можно создать ассоциативный массив

{sum[$1] +=$2;}

Есть условия
{
    if ($1 =="some") {
        print "ogo!"
    }
    else {
        print "aga!"
    }
    else if ($1=="tipidor")
        print "tipidor"
}

Блоки BEGIN и END  - аwk выполняется для каждой строчки, но можно например инициализировать что-то до того, как он начет обрабатывать текст, для этого нежен BEGIN

END выполняется после того, как все строки были обработаны, после него обычно подводятся итоги.

### 21.Использование шаблонов имен файлов в оболочке bash.

Шаблоны имен файлов (и каталогов) задаются с помощью специальных символов.

+ Звездочкка (*) - обозначает любую группу символов. Их количество роли не играет (может быть только один символ или даже не одного). Так например, одиноко стоящая звезда — это шаблон, к которому подходят все файлы каталогов, в которых осуществляется поиск по данному шаблону.Использование шаблона *.html позволит выделить все html-файлы, а шаблона my*.odt – файлы начинающиеся с "my" и оканчивающиеся на ".odt"
+ Знаком вопроса (?) в шаблоне обозначают любой одиночный символ. Например, под шаблон otchet.??? подойдут файлы имеющие любое расширение из трех букв, но начинающиеся именно так, как задано в шаблоне. 

+ Использование квадратных скобок ([ ]) со списком возможных значений позволяет осуществлять более гибкий поиск файлов. Пусть требуется найти все файлы имена которых начинаются с буквы m, при этом требуется не учитывать регистр. Тогда шаблон будет выглядеть так: [mM]*

Диапазон задается так - [0-10]* - все файлы, первый символ которых от 0 до 10


### 22. Простейшие регулярные выражения  в командах grep и sed.

Регулярные выражения — мощный инструмент, используемый во многих утилитах Linux. 
С помощью этих выражений можно описать любую искомую строку.
С помощью «|» можно указать условие «или». В примере ниже grep выдаст все строки с вхождениями user или db. Для обработки подобных выражений необходимо использовать ключ -E или использовать egrep.

Пример: grep -E -i -w 'user|db' /etc/mysql/my.cnf

Символами ^ и $ мы можем указать местоположение искомого слова. ^ обозначает начало строки, $ — его конец.

Найдем все строки, начинющиеся на #

Пример: grep -i '^#' /etc/mysql/my.cnf

Поиск строк, содержащих цифру:

Пример: grep -i '[0-9]' /etc/mysql/my.cnf

Команда sed - это редактор потока данных (Stream EDitor) для автоматического редактирования текстов.
Символ & (амперсанд), будучи помещен в состав ЗАМЕНЫ, означает любой найденный в тексте ОБРАЗЕЦ. Например:

 $ echo 1234 | sed 's/[0-9]*/(&)/'
 (1234)
 
Звездочка (астериск) после интервала [0-9] нужна,  чтобы заменены были все цифры, встретившиеся в образце. Без нее взята была первая же найденная цифра.
с Или любая другая буква. Большинство букв, цифр и прочих неспециальных символов считаются регулярными выражениями, представляющими сами себя.

+ '\+' Означает один или более повтор символа или регулярного выражения.
+ '\?' Означает ни одного или один повтор.
+ '\{i\}' Означает ровно i повторов.
+ '\{i,j\}' Число повторов находится в интервале от i до j включительно.
+ '\{i,\}' Число повторов больше или равно i.
+ '\{,j\} 'Число повторов меньше или равно j.
+ '\(RE\)' Запомнить регулярное выражение или его часть с целью дальнейшего использования как единое целое. Например, \(а-я\)* будет искать любое сочетание любого количества (в том числе и нулевого) строчных букв.
+ '.' Означает любой символ, в том числе символ новой строки.
+ '^' Означает нулевое выражение в начале строки. Другими словами, то, перед чем стоит этот знак, должно появляться в начале строки. Например, ^#include будет искать строки, начинающиеся с #include.
+ '$' То же, что и предыдущее, только относится к концу строки.

+ [СПИСОК] Означает любой символ из СПИСКА. Например, [aeiou] будет искать любую английскую гласную букву.
+ [^СПИСОК] Означает любой символ, кроме тех, что в списке. Например, [^aeiou] будет искать любую согласную. Примечание: СПИСОК может быть интервалом, например [а-я], что будет означать любую строчную букву. Если нужно включить в СПИСОК ] (квадратную скобку) укажите ее в списке первой; если нужно включить в СПИСОК - (дефис), то укажите его в списке первым или последним.
+ 'RE1\|RE2' Означает РВ1 или РВ2.
+ 'RE1RE2' Означает объединение регулярных выражений РВ1 и РВ2.
+ '\n'Означает символ новой строки.

